major_changes:
  - variables - The type system underlying Ansible's variable storage has been significantly overhauled and formalized.
    Attempts to store unsupported Python object types in variables now more consistently yields early warnings or errors.
  - variables - To support new Ansible features, many variable objects are now represented by subclasses of their respective native Python types.
    In most cases, they behave indistinguishably from their original types, but some Python libraries do not handle builtin object subclasses properly.
    Custom plugins that interact with such libraries may require changes to convert and pass the native types.
  - ansible-test - Packages beneath ``module_utils`` can now contain ``__init__.py`` files.
  - Jinja plugins - Jinja builtin filter and test plugins are now accessible via their fully-qualified names ``ansible.builtin.{name}``.

minor_changes:
  - templating - Templating errors now provide more information about both the location and context of the error, especially for deeply-nested and/or indirected templating scenarios.
  - templating - Handling of omitted values is now a first-class feature of the template engine, and is usable in all Ansible Jinja template contexts.
    Any template that resolves to ``omit`` is automatically removed from its parent container during templating.
  - templating - Unified ``omit`` behavior now requires that plugins calling ``Templar.template()`` handle cases where the entire template result is omitted,
    by catching the ``AnsibleValueOmittedError`` that is raised.
    Previously, this condition caused a randomly-generated string marker to appear in the template result.
  - templating - Template evaluation is lazier than in previous versions.
    Template expressions which resolve only portions of a data structure no longer result in the entire structure being templated.
  - handlers - Templated handler names with syntax errors, or that resolve to ``omit`` are now skipped like handlers with undefined variables in their name.
  - env lookup - The error message generated for a missing environment variable when ``default`` is an undefined value (e.g. ``undef('something')``) will contain the hint from that undefined value,
    except when the undefined value is the default of ``undef()`` with no arguments. Previously, any existing undefined hint would be ignored.
  - templating - Embedding ``range()`` values in containers such as lists will result in an error on use.
    Previously the value would be converted to a string representing the range parameters, such as ``range(0, 3)``.
  - Jinja plugins - Plugins can declare support for undefined values.  # DTFIX5: examples, porting guide entry
  - templating - Variables of type ``set`` and ``tuple`` are now converted to ``list`` when exiting the final pass of templating.
  - templating - Access to an undefined variable from inside a lookup, filter, or test (which raises MarkerError) no longer ends processing of the current template.
    The triggering undefined value is returned as the result of the offending plugin invocation, and the template continues to execute. # DTFIX5: porting guide entry, samples needed
  - plugin error handling - When raising exceptions in an exception handler, be sure to use ``raise ... from`` as appropriate.
    This supersedes the use of the ``AnsibleError`` arg ``orig_exc`` to represent the cause.
    Specifying ``orig_exc`` as the cause is still permitted.
    Failure to use ``raise ... from`` when ``orig_exc`` is set will result in a warning.
    Additionally, if the two cause exceptions do not match, a warning will be issued.
  - ansible-test - The ``yamllint`` sanity test now enforces string values for the ``!vault`` tag.
  - warnings - All warnings (including deprecation warnings) issued during a task's execution are now accessible via the ``warnings`` and ``deprecations`` keys on the task result.
  - troubleshooting - Tracebacks can be collected and displayed for most errors, warnings, and deprecation warnings (including those generated by modules).
    Tracebacks are no longer enabled with ``-vvv``; the behavior is directly configurable via the ``DISPLAY_TRACEBACK`` config option.
    Module tracebacks passed to ``fail_json`` via the ``exception`` kwarg will not be included in the task result unless error tracebacks are configured.
  - display - Deduplication of warning and error messages considers the full content of the message (including source and traceback contexts, if enabled).
    This may result in fewer messages being omitted.
  - modules - Unhandled exceptions during Python module execution are now returned as structured data from the target.
    This allows the new traceback handling to be applied to exceptions raised on targets.
  - modules - PowerShell modules can now receive ``datetime.date``, ``datetime.time`` and ``datetime.datetime`` values as ISO 8601 strings.
  - modules - PowerShell modules can now receive strings sourced from inline vault-encrypted strings.
  - from_json filter - The filter accepts a ``profile`` argument, which defaults to ``tagless``.
  - to_json / to_nice_json filters - The filters accept a ``profile`` argument, which defaults to ``tagless``.
  - undef jinja function - The ``undef`` jinja function now raises an error if a non-string hint is given.
    Attempting to use an undefined hint also results in an error, ensuring incorrect use of the function can be distinguished from the function's normal behavior.

breaking_changes:
  - loops - Omit placeholders no longer leak between loop item templating and task templating.
    Previously, ``omit`` placeholders could remain embedded in loop items after templating and be used as an ``omit`` for task templating.
    Now, values resolving to ``omit`` are dropped immediately when loop items are templated.
    To turn missing values into an ``omit`` for task templating, use ``| default(omit)``.
    This solution is backward-compatible with previous versions of ansible-core.
  - serialization of ``omit`` sentinel - Serialization of variables containing ``omit`` sentinels (e.g., by the ``to_json`` and ``to_yaml`` filters or ``ansible-inventory``) will fail if the variable has not completed templating.
    Previously, serialization succeeded with placeholder strings emitted in the serialized output.
  - conditionals - Conditional expressions that result in non-boolean values are now an error by default.
    Such results often indicate unintentional use of templates where they are not supported, resulting in a conditional that is always true.
    When this option is enabled, conditional expressions which are a literal ``None`` or empty string will evaluate as true, for backwards compatibility.
    The error can be temporarily changed to a deprecation warning by enabling the ``ALLOW_BROKEN_CONDITIONALS`` config option.
  - templating - Templates are always rendered in Jinja2 native mode.
    As a result, non-string values are no longer automatically converted to strings.
  - templating - Templates with embedded inline templates that were not contained within a Jinja string constant now result in an error, as support for multi-pass templating was removed for security reasons.
    In most cases, such templates can be easily rewritten to avoid the use of embedded inline templates.
  - templating - Conditionals and lookups which use embedded inline templates in Jinja string constants now display a warning.
    These templates should be converted to their expression equivalent.
  - templating - Templates resulting in ``None`` are no longer automatically converted to an empty string.
  - template lookup - The ``convert_data`` option is deprecated and no longer has any effect.
    Use the ``from_json`` filter on the lookup result instead.
  - templating - ``#jinja2:`` overrides in templates with invalid override names or types are now templating errors.
  - set_fact - The string values "yes", "no", "true" and "false" were previously converted (ignoring case) to boolean values when not using Jinja2 native mode.
    Since Jinja2 native mode is always used, this conversion no longer occurs.
    When boolean values are required, native boolean syntax should be used where variables are defined, such as in YAML.
    When native boolean syntax is not an option, the ``bool`` filter can be used to parse string values into booleans.
  - templating - The ``allow_unsafe_lookups`` option no longer has any effect.
    Lookup plugins are responsible for tagging strings containing templates to allow evaluation as a template.
  - assert - The ``quiet`` argument must be a commonly-accepted boolean value.
    Previously, unrecognized values were silently treated as False.
  - plugins - Any plugin that sources or creates templates must properly tag them as trusted. # DTFIX5: porting guide entry for "how?" Don't forget to mention inventory plugin ``trusted_by_default`` config.
  - first_found lookup - When specifying ``files`` or ``paths`` as a templated list containing undefined values, the undefined list elements will be discarded with a warning.
    Previously, the entire list would be discarded without any warning.
  - templating - The result of the ``range()`` global function cannot be returned from a template- it should always be passed to a filter (e.g., ``random``).
    Previously, range objects returned from an intermediate template were always converted to a list, which is inconsistent with inline consumption of range objects.
  - plugins - Custom Jinja plugins that accept undefined top-level arguments must opt in to receiving them.  # DTFIX5: porting guide entry + backcompat behavior description
  - plugins - Custom Jinja plugins that use ``environment.getitem`` to retrieve undefined values will now trigger a ``MarkerError`` exception.
    This exception must be handled to allow the plugin to return a ``Marker``, or the plugin must opt-in to accepting ``Marker`` values.  # DTFIX5: mention the decorator
  - templating - Many Jinja plugins (filters, lookups, tests) and methods previously silently ignored undefined inputs, which often masked subtle errors.
    Passing an undefined argument to a Jinja plugin or method that does not declare undefined support now results in an undefined value.  # DTFIX5: common examples, porting guide, `is defined`, `is undefined`, etc; porting guide should also mention that overly-broad exception handling may mask Undefined errors; also that lazy handling of Undefined can invoke a plugin and bomb out in the middle where it was previously never invoked (plugins with side effects, just don't)
  - lookup plugins - Lookup plugins called as `with_(lookup)` will no longer have the `_subdir` attribute set.
  - lookup plugins - ``terms`` will always be passed to ``run`` as the first positional arg, where previously it was sometimes passed as a keyword arg when using ``with_`` syntax.
  - modules - Ansible modules using ``sys.excepthook`` must use a standard ``try/except`` instead.
  - templating - Access to ``_`` prefixed attributes and methods, and methods with known side effects, is no longer permitted.
    In cases where a matching mapping key is present, the associated value will be returned instead of an error. 
    This increases template environment isolation and ensures more consistent behavior between the ``.`` and ``[]`` operators.
  - inventory - Invalid variable names provided by inventories result in an inventory parse failure. This behavior is now consistent with other variable name usages throughout Ansible.
  - internals - The ``ansible.utils.native_jinja`` Python module has been removed.
  - internals - The ``AnsibleLoader`` and ``AnsibleDumper`` classes for working with YAML are now factory functions and cannot be extended.
  - public API - The ``ansible.vars.fact_cache.FactCache`` wrapper has been removed.

security_fixes:
  - templating - Ansible's template engine no longer processes Jinja templates in strings unless they are marked as coming from a trusted source.
    Untrusted strings containing Jinja template markers are ignored with a warning.
    Examples of trusted sources include playbooks, vars files, and many inventory sources.
    Examples of untrusted sources include module results and facts.
    Plugins which have not been updated to preserve trust while manipulating strings may inadvertently cause them to lose their trusted status.
  - templating - Changes to conditional expression handling removed numerous instances of insecure multi-pass templating (which could result in execution of untrusted template expressions).

bugfixes:
  - module defaults - Module defaults are no longer templated unless they are used by a task that does not override them.
    Previously, all module defaults for all modules were templated for every task.
  - regex_search filter - Corrected return value documentation to reflect None (not empty string) for no match.
  - first_found lookup - Corrected return value documentation to reflect None (not empty string) for no files found.
  - vars lookup - The ``default`` substitution only applies when trying to look up a variable which is not defined.
    If the variable is defined, but templates to an undefined value, the ``default`` substitution will not apply.
    Use the ``default`` filter to coerce those values instead.
  - to_yaml/to_nice_yaml filters - Eliminated possibility of keyword arg collisions with internally-set defaults.
  - Jinja plugins - Errors raised will always be derived from ``AnsibleTemplatePluginError``.
  - ansible-test - Fixed traceback when handling certain YAML errors in the ``yamllint`` sanity test.
  - YAML parsing - The `!unsafe` tag no longer coerces non-string scalars to strings.
  - default callback - Error context is now shown for failing tasks that use the ``debug`` action.
  - module arg templating - When using a templated raw task arg and a templated ``args`` keyword, args are now merged.
    Previously use of templated raw task args silently ignored all values from the templated ``args`` keyword.
  - action plugins - Action plugins that raise unhandled exceptions no longer terminate playbook loops. Previously, exceptions raised by an action plugin caused abnormal loop termination and loss of loop iteration results.
  - display - The ``Display.deprecated`` method once again properly handles the ``removed=True`` argument (https://github.com/ansible/ansible/issues/82358).
  - stability - Fixed silent process failure on unhandled IOError/OSError under ``linear`` strategy.
  - lookup plugins - The ``terms`` arg to the ``run`` method is now always a list.
    Previously, there were cases where a non-list could be received.

deprecated_features:
  - display - The ``Display.get_deprecation_message`` method has been deprecated.
    Call ``Display.deprecated`` to display a deprecation message, or call it with ``removed=True`` to raise an ``AnsibleError``.
  - config - The ``DEFAULT_JINJA2_NATIVE`` option has no effect.
    Jinja2 native mode is now the default and only option.
  - config - The ``DEFAULT_NULL_REPRESENTATION`` option has no effect.
    Null values are no longer automatically converted to another value during templating of single variable references.
  - template lookup - The jinja2_native option is no longer used in the Ansible Core code base.
    Jinja2 native mode is now the default and only option.
  - conditionals - Conditionals using Jinja templating delimiters (e.g., ``{{``, ``{%``) should be rewritten as expressions without delimiters, unless the entire conditional value is a single template that resolves to a trusted string expression.
    This is useful for dynamic indirection of conditional expressions, but is limited to trusted literal string expressions.
  - templating - The ``disable_lookups`` option has no effect, since plugins must be updated to apply trust before any templating can be performed.
  - plugin error handling - The ``AnsibleError`` constructor arg ``suppress_extended_error`` is deprecated.
    Using ``suppress_extended_error=True`` has the same effect as ``show_content=False``.
  - config - The ``ACTION_WARNINGS`` config has no effect. It previously disabled command warnings, which have since been removed.
  - templating - Support for enabling Jinja2 extensions (not plugins) has been deprecated.
  - playbook variables - The ``play_hosts`` variable has been deprecated, use ``ansible_play_batch`` instead.
  - bool filter - Support for coercing unrecognized input values (including None) has been deprecated. Consult the filter documentation for acceptable values, or consider use of the ``truthy`` and ``falsy`` tests.
  - oneline callback - The ``oneline`` callback and its associated ad-hoc CLI args (``-o``, ``--one-line``) are deprecated.
  - tree callback - The ``tree`` callback and its associated ad-hoc CLI args (``-t``, ``--tree``) are deprecated.
  - CLI - The ``--inventory-file`` option alias is deprecated. Use the ``-i`` or ``--inventory`` option instead.
  - first_found lookup - Splitting of file paths on ``,;:`` is deprecated. Pass a list of paths instead.
    The ``split`` method on strings can be used to split variables into a list as needed.
  - cache plugins - The `ansible.plugins.cache.base` Python module is deprecated. Use `ansible.plugins.cache` instead.
  - file loading - Loading text files with ``DataLoader`` containing data that cannot be decoded under the expected encoding is deprecated.
    In most cases the encoding must be UTF-8, although some plugins allow choosing a different encoding.
    Previously, invalid data was silently wrapped in Unicode surrogate escape sequences, often resulting in later errors or other data corruption.
  - callback plugins - The v1 callback API (callback methods not prefixed with `v2_`) is deprecated.
    Use `v2_` prefixed methods instead.
  - callback plugins - The `v2_on_any` callback method is deprecated. Use specific callback methods instead.

removed_features:
  - modules - Modules returning non-UTF8 strings now result in an error.
    The ``MODULE_STRICT_UTF8_RESPONSE`` setting can be used to disable this check.
